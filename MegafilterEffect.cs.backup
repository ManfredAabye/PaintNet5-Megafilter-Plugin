using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text.Json;
using PaintDotNet;
using PaintDotNet.Effects;
using PaintDotNet.Imaging;
using PaintDotNet.IndirectUI;
using PaintDotNet.PropertySystem;
using PaintDotNet.Rendering;
using PaintDotNet.Direct2D1;
using PaintDotNet.Collections;

namespace Megafilter;

[PluginSupportInfo(typeof(PluginSupportInfo))]
public sealed class MegafilterEffect : PropertyBasedEffect
{
    private FilterDefinitions? _filterDefinitions;
    
    public MegafilterEffect()
        : base("Megafilter", 
               null,
               "Effects",  
               new EffectOptions { Flags = EffectFlags.Configurable })
    {
        LoadFilterDefinitions();
    }

    private void LoadFilterDefinitions()
    {
        try
        {
            string jsonPath = Path.Combine(Path.GetDirectoryName(GetType().Assembly.Location) ?? "", "FilterDefinitions.json");
            if (File.Exists(jsonPath))
            {
                string jsonContent = File.ReadAllText(jsonPath);
                _filterDefinitions = JsonSerializer.Deserialize<FilterDefinitions>(jsonContent);
            }
        }
        catch (Exception)
        {
            _filterDefinitions = new FilterDefinitions();
        }
    }

    protected override PropertyCollection OnCreatePropertyCollection()
    {
        var properties = new List<Property>();

        if (_filterDefinitions != null && _filterDefinitions.Filters.Count > 0)
        {
            var filterNames = _filterDefinitions.Filters.Select(f => f.Name).ToArray();
            properties.Add(new StaticListChoiceProperty("FilterType", filterNames, 0));

            foreach (var filter in _filterDefinitions.Filters)
            {
                foreach (var param in filter.Parameters)
                {
                    string propName = $"{filter.Id}_{param.Name}";
                    
                    if (param.Type == "double")
                    {
                        properties.Add(new DoubleProperty(propName, param.Default, param.Min, param.Max));
                    }
                    else
                    {
                        properties.Add(new Int32Property(propName, (int)param.Default, (int)param.Min, (int)param.Max));
                    }
                }
            }
        }

        return new PropertyCollection(properties);
    }

    protected override void OnRender(IBitmapEffectOutput output)
    {
        if (_filterDefinitions == null || _filterDefinitions.Filters.Count == 0)
            return;

        var filterTypeProperty = (StaticListChoiceProperty)Token.GetProperty("FilterType")!;
        int filterIndex = (int)filterTypeProperty.Value;
        var selectedFilter = _filterDefinitions.Filters[filterIndex];

        using var source = Environment.GetSourceBitmapBgra32();
        using var dest = output.LockBgra32();
        
        var bounds = output.Bounds;
        var srcSize = source.Size;

        // For blur filter, cache source pixels
        ColorBgra32[,]? sourceCache = null;
        if (selectedFilter.Id == "blur")
        {
            sourceCache = new ColorBgra32[srcSize.Width, srcSize.Height];
            for (int sy = 0; sy < srcSize.Height; sy++)
            {
                for (int sx = 0; sx < srcSize.Width; sx++)
                {
                    // Read via CopyPixels method
                    var tempSpan = new Span<ColorBgra32>(new ColorBgra32[1]);
                    source.CopyPixels(new RectInt32(sx, sy, 1, 1), tempSpan);
                    sourceCache[sx, sy] = tempSpan[0];
                }
            }
        }

        // Process each pixel
        for (int y = bounds.Y; y < bounds.Bottom; y++)
        {
            if (IsCancelRequested)
                return;

            for (int x = bounds.X; x < bounds.Right; x++)
            {
                if (x >= 0 && x < srcSize.Width && y >= 0 && y < srcSize.Height)
                {
                    ColorBgra32 result;

                    // Special handling for blur (needs neighboring pixels)
                    if (selectedFilter.Id == "blur" && sourceCache != null)
                    {
                        result = ApplyBlur(sourceCache, x, y, srcSize.Width, srcSize.Height, selectedFilter);
                    }
                    else
                    {
                        // Read source pixel
                        var pixelSpan = new Span<ColorBgra32>(new ColorBgra32[1]);
                        source.CopyPixels(new RectInt32(x, y, 1, 1), pixelSpan);
                        ColorBgra32 pixel = pixelSpan[0];
                        
                        result = ProcessPixel(pixel, selectedFilter, x, y, srcSize.Width, srcSize.Height);
                    }
                    
                    // Write result pixel
                    var resultSpan = new ReadOnlySpan<ColorBgra32>(new[] { result });
                    dest.WritePixels(new RectInt32(x, y, 1, 1), resultSpan);
                }
            }
        }
    }

    private ColorBgra32 ProcessPixel(ColorBgra32 pixel, FilterDefinition filter, int x, int y, int width, int height)
    {
        return filter.Id switch
        {
            "brightness" => ApplyBrightness(pixel, GetParameterValue(filter, "amount")),
            "contrast" => ApplyContrast(pixel, GetParameterValue(filter, "amount")),
            "saturation" => ApplySaturation(pixel, GetParameterValue(filter, "amount")),
            "sharpen" => ApplySharpen(pixel, GetParameterValue(filter, "amount")),
            "hueshift" => ApplyHueShift(pixel, GetParameterValue(filter, "degrees")),
            "vignette" => ApplyVignette(pixel, x, y, width, height, 
                                         GetParameterValue(filter, "strength"), 
                                         GetParameterValue(filter, "radius")),
            "sepia" => ApplySepia(pixel, GetParameterValue(filter, "intensity")),
            _ => pixel
        };
    }

    private double GetParameterValue(FilterDefinition filter, params string[] paramNames)
    {
        foreach (var paramName in paramNames)
        {
            string propName = $"{filter.Id}_{paramName}";
            var property = Token.GetProperty(propName);
            
            if (property is Int32Property intProp)
                return intProp.Value;
            else if (property is DoubleProperty doubleProp)
                return doubleProp.Value;
        }
        return 0;
    }

    private ColorBgra32 ApplyBrightness(ColorBgra32 pixel, double amount)
    {
        int adjustment = (int)(amount * 2.55);
        return ColorBgra32.FromBgra(
            (byte)Math.Clamp(pixel.B + adjustment, 0, 255),
            (byte)Math.Clamp(pixel.G + adjustment, 0, 255),
            (byte)Math.Clamp(pixel.R + adjustment, 0, 255),
            pixel.A);
    }

    private ColorBgra32 ApplyContrast(ColorBgra32 pixel, double amount)
    {
        double contrast = (amount + 100.0) / 100.0;
        contrast *= contrast;

        int r = (int)Math.Clamp((int)(((pixel.R / 255.0 - 0.5) * contrast + 0.5) * 255.0), 0, 255);
        int g = (int)Math.Clamp((int)(((pixel.G / 255.0 - 0.5) * contrast + 0.5) * 255.0), 0, 255);
        int b = (int)Math.Clamp((int)(((pixel.B / 255.0 - 0.5) * contrast + 0.5) * 255.0), 0, 255);

        return ColorBgra32.FromBgra((byte)b, (byte)g, (byte)r, pixel.A);
    }

    private ColorBgra32 ApplySaturation(ColorBgra32 pixel, double amount)
    {
        double saturation = (amount + 100.0) / 100.0;
        int gray = (int)(pixel.R * 0.299 + pixel.G * 0.587 + pixel.B * 0.114);

        int r = (int)Math.Clamp((int)(gray + (pixel.R - gray) * saturation), 0, 255);
        int g = (int)Math.Clamp((int)(gray + (pixel.G - gray) * saturation), 0, 255);
        int b = (int)Math.Clamp((int)(gray + (pixel.B - gray) * saturation), 0, 255);

        return ColorBgra32.FromBgra((byte)b, (byte)g, (byte)r, pixel.A);
    }

    private ColorBgra32 ApplyBlur(ColorBgra32[,] source, int x, int y, int width, int height, FilterDefinition filter)
    {
        double radius = GetParameterValue(filter, "radius");
        int kernelSize = (int)Math.Max(1, radius / 10.0); // radius 0-100 -> kernelSize 0-10
        
        if (kernelSize == 0)
            return source[x, y];

        int r = 0, g = 0, b = 0, count = 0;
        
        for (int dy = -kernelSize; dy <= kernelSize; dy++)
        {
            for (int dx = -kernelSize; dx <= kernelSize; dx++)
            {
                int nx = x + dx;
                int ny = y + dy;
                
                if (nx >= 0 && nx < width && ny >= 0 && ny < height)
                {
                    var pixel = source[nx, ny];
                    r += pixel.R;
                    g += pixel.G;
                    b += pixel.B;
                    count++;
                }
            }
        }
        
        if (count > 0)
        {
            return ColorBgra32.FromBgra(
                (byte)(b / count),
                (byte)(g / count),
                (byte)(r / count),
                source[x, y].A);
        }
        
        return source[x, y];
    }

    private ColorBgra32 ApplySharpen(ColorBgra32 pixel, double amount)
    {
        // Simplified sharpening by enhancing contrast
        // In real implementation, would need neighboring pixels
        double factor = 1.0 + (amount / 100.0);
        
        int r = (int)Math.Clamp(pixel.R * factor, 0, 255);
        int g = (int)Math.Clamp(pixel.G * factor, 0, 255);
        int b = (int)Math.Clamp(pixel.B * factor, 0, 255);
        
        return ColorBgra32.FromBgra((byte)b, (byte)g, (byte)r, pixel.A);
    }

    private ColorBgra32 ApplyHueShift(ColorBgra32 pixel, double degrees)
    {
        // Convert RGB to HSV
        double r = pixel.R / 255.0;
        double g = pixel.G / 255.0;
        double b = pixel.B / 255.0;
        
        double max = Math.Max(r, Math.Max(g, b));
        double min = Math.Min(r, Math.Min(g, b));
        double delta = max - min;
        
        double h = 0, s = 0, v = max;
        
        if (delta > 0)
        {
            s = delta / max;
            
            if (r == max)
                h = (g - b) / delta + (g < b ? 6 : 0);
            else if (g == max)
                h = (b - r) / delta + 2;
            else
                h = (r - g) / delta + 4;
            
            h /= 6;
        }
        
        // Shift hue
        h += degrees / 360.0;
        while (h < 0) h += 1;
        while (h > 1) h -= 1;
        
        // Convert HSV back to RGB
        double nr, ng, nb;
        
        if (s == 0)
        {
            nr = ng = nb = v;
        }
        else
        {
            h *= 6;
            int i = (int)h;
            double f = h - i;
            double p = v * (1 - s);
            double q = v * (1 - s * f);
            double t = v * (1 - s * (1 - f));
            
            switch (i % 6)
            {
                case 0: nr = v; ng = t; nb = p; break;
                case 1: nr = q; ng = v; nb = p; break;
                case 2: nr = p; ng = v; nb = t; break;
                case 3: nr = p; ng = q; nb = v; break;
                case 4: nr = t; ng = p; nb = v; break;
                default: nr = v; ng = p; nb = q; break;
            }
        }
        
        return ColorBgra32.FromBgra(
            (byte)(nb * 255),
            (byte)(ng * 255),
            (byte)(nr * 255),
            pixel.A);
    }

    private ColorBgra32 ApplyVignette(ColorBgra32 pixel, int x, int y, int width, int height, double strength, double radius)
    {
        // Calculate distance from center
        double centerX = width / 2.0;
        double centerY = height / 2.0;
        double dx = (x - centerX) / centerX;
        double dy = (y - centerY) / centerY;
        double distance = Math.Sqrt(dx * dx + dy * dy);
        
        // Apply vignette based on distance and radius
        double vignette = 1.0 - Math.Pow(distance * radius, 2) * (strength / 100.0);
        vignette = Math.Max(0, Math.Min(1, vignette));
        
        return ColorBgra32.FromBgra(
            (byte)(pixel.B * vignette),
            (byte)(pixel.G * vignette),
            (byte)(pixel.R * vignette),
            pixel.A);
    }

    private ColorBgra32 ApplySepia(ColorBgra32 pixel, double intensity)
    {
        // Sepia tone transformation
        double factor = intensity / 100.0;
        
        int tr = (int)(pixel.R * 0.393 + pixel.G * 0.769 + pixel.B * 0.189);
        int tg = (int)(pixel.R * 0.349 + pixel.G * 0.686 + pixel.B * 0.168);
        int tb = (int)(pixel.R * 0.272 + pixel.G * 0.534 + pixel.B * 0.131);
        
        // Blend with original based on intensity
        int r = (int)(pixel.R * (1 - factor) + tr * factor);
        int g = (int)(pixel.G * (1 - factor) + tg * factor);
        int b = (int)(pixel.B * (1 - factor) + tb * factor);
        
        return ColorBgra32.FromBgra(
            (byte)Math.Clamp(b, 0, 255),
            (byte)Math.Clamp(g, 0, 255),
            (byte)Math.Clamp(r, 0, 255),
            pixel.A);
    }
}
